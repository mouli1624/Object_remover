<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Object Remover - Professional Image Editing</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 40px 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .header {
      text-align: center;
      color: white;
      margin-bottom: 40px;
      animation: fadeInDown 0.8s ease;
    }

    .header h1 {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 10px;
      text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }

    .header p {
      font-size: 1.1rem;
      opacity: 0.95;
      font-weight: 300;
    }

    .container {
      width: 100%;
      max-width: 1600px;
      background: white;
      padding: 40px;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      animation: fadeInUp 0.8s ease;
    }

    .main-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin-top: 30px;
    }

    @media (max-width: 1024px) {
      .main-grid {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      background: #f8f9fa;
      border-radius: 12px;
      padding: 25px;
      border: 2px solid #e2e8f0;
    }

    .panel-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .panel-title .icon {
      font-size: 1.3rem;
    }

    .section-title {
      font-size: 1.3rem;
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .section-title::before {
      content: '';
      width: 4px;
      height: 24px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 2px;
    }

    .mode-toggle {
      margin-bottom: 30px;
      display: flex;
      gap: 15px;
      background: #f7fafc;
      padding: 8px;
      border-radius: 12px;
      width: fit-content;
    }

    .mode-toggle button {
      padding: 12px 28px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      background: transparent;
      color: #4a5568;
      font-weight: 500;
      font-size: 0.95rem;
      transition: all 0.3s ease;
      position: relative;
    }

    .mode-toggle button:hover {
      color: #667eea;
    }

    .mode-toggle button.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 30px;
      align-items: center;
    }

    .file-input-wrapper {
      position: relative;
      overflow: hidden;
      display: inline-block;
    }

    .file-input-wrapper input[type=file] {
      position: absolute;
      left: -9999px;
    }

    .file-input-label {
      padding: 12px 24px;
      background: #f7fafc;
      border: 2px dashed #cbd5e0;
      border-radius: 10px;
      cursor: pointer;
      display: inline-block;
      font-weight: 500;
      color: #4a5568;
      transition: all 0.3s ease;
    }

    .file-input-label:hover {
      border-color: #667eea;
      color: #667eea;
      background: #edf2f7;
    }

    .controls button {
      padding: 12px 28px;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      font-weight: 500;
      font-size: 0.95rem;
      transition: all 0.3s ease;
    }

    #processBtn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    #processBtn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
    }

    #processBtn:active {
      transform: translateY(0);
    }

    #clearBtn {
      background: #fff;
      color: #e53e3e;
      border: 2px solid #e53e3e;
    }

    #clearBtn:hover {
      background: #e53e3e;
      color: white;
    }

    .canvas-container {
      position: relative;
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      margin-bottom: 30px;
      overflow: hidden;
      background: #f7fafc;
      min-height: 400px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .canvas-container.has-image {
      background: #fff;
    }

    .canvas-placeholder {
      text-align: center;
      color: #a0aec0;
      padding: 60px 20px;
    }

    .canvas-placeholder svg {
      width: 80px;
      height: 80px;
      margin-bottom: 20px;
      opacity: 0.5;
    }

    canvas {
      display: block;
      max-width: 100%;
      cursor: crosshair;
    }

    .brush-size-control {
      display: flex;
      align-items: center;
      gap: 10px;
      background: #f7fafc;
      padding: 10px 20px;
      border-radius: 10px;
    }

    .brush-size-control label {
      font-weight: 500;
      color: #4a5568;
      font-size: 0.9rem;
    }

    .brush-size-control input[type="range"] {
      width: 120px;
      cursor: pointer;
    }

    .brush-size-value {
      font-weight: 600;
      color: #667eea;
      min-width: 35px;
    }

    .result-container {
      margin-top: 30px;
      display: none;
    }

    .result-container.show {
      display: block;
      animation: fadeIn 0.5s ease;
    }

    .result-container img {
      max-width: 100%;
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    .status {
      margin-top: 20px;
      padding: 15px 20px;
      border-radius: 10px;
      font-weight: 500;
      text-align: center;
      display: none;
    }

    .status.show {
      display: block;
      animation: fadeIn 0.3s ease;
    }

    .status.success {
      background: #c6f6d5;
      color: #22543d;
      border: 1px solid #9ae6b4;
    }

    .status.error {
      background: #fed7d7;
      color: #742a2a;
      border: 1px solid #fc8181;
    }

    .status.info {
      background: #bee3f8;
      color: #2c5282;
      border: 1px solid #90cdf4;
    }

    .features {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-top: 30px;
      padding-top: 30px;
      border-top: 1px solid #e2e8f0;
    }

    .feature {
      text-align: center;
      padding: 20px;
    }

    .feature-icon {
      font-size: 2rem;
      margin-bottom: 10px;
    }

    .feature h3 {
      font-size: 0.95rem;
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 5px;
    }

    .feature p {
      font-size: 0.85rem;
      color: #718096;
      line-height: 1.5;
    }

    @keyframes fadeInDown {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    /* Loading Animation */
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.95);
      display: none;
      align-items: center;
      justify-content: center;
      border-radius: 12px;
      z-index: 10;
    }

    .loading-overlay.show {
      display: flex;
    }

    .loading-content {
      text-align: center;
    }

    .spinner {
      width: 60px;
      height: 60px;
      margin: 0 auto 20px;
      border: 4px solid #e2e8f0;
      border-top: 4px solid #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .loading-text {
      font-size: 1.1rem;
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 8px;
    }

    .loading-subtext {
      font-size: 0.9rem;
      color: #718096;
    }

    .progress-bar {
      width: 200px;
      height: 4px;
      background: #e2e8f0;
      border-radius: 2px;
      margin: 15px auto 0;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea, #764ba2);
      width: 0%;
      animation: progress 3s ease-in-out infinite;
    }

    @keyframes progress {
      0% { width: 0%; }
      50% { width: 70%; }
      100% { width: 100%; }
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }

    .result-ready {
      animation: pulse 0.5s ease;
    }

    @media (max-width: 768px) {
      .header h1 {
        font-size: 2rem;
      }
      
      .container {
        padding: 25px;
      }

      .controls {
        flex-direction: column;
        width: 100%;
      }

      .controls button, .file-input-label {
        width: 100%;
        text-align: center;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>‚ú® AI Object Remover</h1>
    <p>Remove unwanted objects from your images with precision</p>
  </div>

  <div class="container">
    <div class="section-title">Select Mode</div>
    
    <div class="mode-toggle">
      <button id="maskMode" class="active">üñåÔ∏è Brush Mode</button>
      <button id="samMode">üéØ SAM Mode</button>
      <button id="yoloMode">ü§ñ YOLO Mode</button>
    </div>

    <div class="controls">
      <div class="file-input-wrapper">
        <input type="file" id="imageUpload" accept="image/*">
        <label for="imageUpload" class="file-input-label">
          üìÅ Choose Image
        </label>
      </div>
      <div class="brush-size-control">
        <label>Brush Size:</label>
        <input type="range" id="brushSize" min="5" max="50" value="20">
        <span class="brush-size-value" id="brushSizeValue">20</span>
      </div>
      <button id="processBtn">üöÄ Process Image</button>
      <button id="removeBtn" style="display: none;">‚ú® Remove Object</button>
      <button id="clearBtn">üóëÔ∏è Clear Mask</button>
      <!-- SAM Interactive Controls -->
      <button id="addMaskBtn" style="display: none;">‚ûï Add Mask</button>
      <button id="deleteMasksBtn" style="display: none;">üóëÔ∏è Delete All Masks</button>
    </div>

    <div id="status" class="status"></div>

    <!-- Side by Side Layout -->
    <div class="main-grid">
      <!-- Input Panel -->
      <div class="panel">
        <div class="panel-title">
          <span class="icon">üì∏</span>
          Input Image
        </div>
        <div class="canvas-container" id="canvasContainer" style="position: relative;">
          <div class="canvas-placeholder" id="placeholder">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
            </svg>
            <h3>Upload an image to get started</h3>
            <p>Supports JPG, PNG, and other common formats</p>
          </div>
          <canvas id="imageCanvas"></canvas>
          <!-- Loading overlay for processing -->
          <div class="loading-overlay" id="processingLoader">
            <div class="loading-content">
              <div class="spinner"></div>
              <div class="loading-text">Processing Image...</div>
              <div class="loading-subtext">Generating mask with AI</div>
              <div class="progress-bar">
                <div class="progress-fill"></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Output Panel -->
      <div class="panel">
        <div class="panel-title">
          <span class="icon">‚ú®</span>
          Result
        </div>
        <div class="result-container" id="resultContainer" style="position: relative; display: block;">
          <div class="canvas-placeholder" id="resultPlaceholder" style="min-height: 400px; display: flex;">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z" />
            </svg>
            <h3>Result will appear here</h3>
            <p>Process an image and remove objects to see the result</p>
          </div>
          <img id="resultImage" src="" alt="Processed result" style="display: none; max-width: 100%; border-radius: 12px;">
          <!-- Loading overlay for inpainting -->
          <div class="loading-overlay" id="inpaintingLoader">
            <div class="loading-content">
              <div class="spinner"></div>
              <div class="loading-text">Removing Object...</div>
              <div class="loading-subtext">LaMa is working its magic ‚ú®</div>
              <div class="progress-bar">
                <div class="progress-fill"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="features">
      <div class="feature">
        <div class="feature-icon">üéØ</div>
        <h3>Precise Selection</h3>
        <p>Use brush or click mode for accurate object selection</p>
      </div>
      <div class="feature">
        <div class="feature-icon">‚ö°</div>
        <h3>Fast Processing</h3>
        <p>AI-powered removal in seconds</p>
      </div>
      <div class="feature">
        <div class="feature-icon">üé®</div>
        <h3>Smart Inpainting</h3>
        <p>Seamlessly fills removed areas</p>
      </div>
    </div>
  </div>

  <script>
    // Elements
    const canvas = document.getElementById('imageCanvas');
    const ctx = canvas.getContext('2d');
    const imageUpload = document.getElementById('imageUpload');
    const processBtn = document.getElementById('processBtn');
    const removeBtn = document.getElementById('removeBtn');
    const clearBtn = document.getElementById('clearBtn');
    const maskModeBtn = document.getElementById('maskMode');
    const samModeBtn = document.getElementById('samMode');
    const yoloModeBtn = document.getElementById('yoloMode');
    const resultImage = document.getElementById('resultImage');
    const statusDiv = document.getElementById('status');
    const canvasContainer = document.getElementById('canvasContainer');
    const placeholder = document.getElementById('placeholder');
    const resultContainer = document.getElementById('resultContainer');
    const brushSizeInput = document.getElementById('brushSize');
    const brushSizeValue = document.getElementById('brushSizeValue');
    const processingLoader = document.getElementById('processingLoader');
    const inpaintingLoader = document.getElementById('inpaintingLoader');
    const resultPlaceholder = document.getElementById('resultPlaceholder');

    // State
    let currentImage = null;
    let isDrawing = false;
    let mode = 'mask'; // 'mask', 'sam', or 'yolo'
    let maskCanvas = document.createElement('canvas');
    let maskCtx = maskCanvas.getContext('2d');
    let clickPoints = [];
    let brushSize = 20;
    let lastUploadResult = null; // Store upload result for inpainting
    let samSessionId = 'default';
    let samMasks = [];
    const addMaskBtn = document.getElementById('addMaskBtn');
    const deleteMasksBtn = document.getElementById('deleteMasksBtn');

    // Brush size control
    brushSizeInput.addEventListener('input', (e) => {
      brushSize = parseInt(e.target.value);
      brushSizeValue.textContent = brushSize;
    });

    // Set initial mode buttons
    maskModeBtn.addEventListener('click', () => {
      mode = 'mask';
      maskModeBtn.classList.add('active');
      samModeBtn.classList.remove('active');
      yoloModeBtn.classList.remove('active');
      
      // Show normal controls
      processBtn.style.display = 'inline-block';
      addMaskBtn.style.display = 'none';
      deleteMasksBtn.style.display = 'none';
      removeBtn.style.display = 'none';
      
      showStatus('Brush Mode: Paint over objects to remove', 'info');
      setTimeout(hideStatus, 3000);
    });

    samModeBtn.addEventListener('click', () => {
      mode = 'sam';
      samModeBtn.classList.add('active');
      maskModeBtn.classList.remove('active');
      yoloModeBtn.classList.remove('active');
      
      // Show SAM controls, hide process button
      processBtn.style.display = 'none';
      addMaskBtn.style.display = 'inline-block';
      deleteMasksBtn.style.display = 'inline-block';
      removeBtn.style.display = 'inline-block';
      removeBtn.textContent = '‚ú® Process & Remove';
      
      // Upload image to SAM if we have one
      if (currentImage) {
        uploadToSAM();
      }
      
      showStatus('SAM Interactive Mode: Click to add points, then Add Mask to save', 'info');
      setTimeout(hideStatus, 3000);
    });

    yoloModeBtn.addEventListener('click', () => {
      mode = 'yolo';
      yoloModeBtn.classList.add('active');
      maskModeBtn.classList.remove('active');
      samModeBtn.classList.remove('active');
      
      // Show normal controls
      processBtn.style.display = 'inline-block';
      addMaskBtn.style.display = 'none';
      deleteMasksBtn.style.display = 'none';
      removeBtn.style.display = 'none';
      
      showStatus('YOLO Mode: Click on objects for instant detection & segmentation', 'info');
      setTimeout(hideStatus, 3000);
    });

    // Status helper functions
    function showStatus(message, type = 'info') {
      statusDiv.textContent = message;
      statusDiv.className = `status show ${type}`;
    }

    function hideStatus() {
      statusDiv.className = 'status';
    }

    // Handle image upload
    imageUpload.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
          currentImage = img;
          // Set canvas dimensions to match image
          canvas.width = img.width;
          canvas.height = img.height;
          maskCanvas.width = img.width;
          maskCanvas.height = img.height;
          
          // Clear previous mask
          maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
          clickPoints = [];
          
          // Draw image
          ctx.drawImage(img, 0, 0);
          
          // Hide placeholder and show canvas
          placeholder.style.display = 'none';
          canvas.style.display = 'block';
          canvasContainer.classList.add('has-image');
          
          // Hide result container
          resultContainer.classList.remove('show');
          hideStatus();
          
          // If in SAM mode, upload to SAM service
          if (mode === 'sam') {
            uploadToSAM();
          }
          
          showStatus('Image loaded successfully! Start marking objects to remove.', 'success');
          setTimeout(hideStatus, 3000);
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    // Drawing functionality
    let lastX = 0;
    let lastY = 0;
    
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseout', stopDrawing);

    function startDrawing(e) {
      if (!currentImage) return;
      isDrawing = true;
      
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      
      lastX = x;
      lastY = y;
      
      if (mode === 'mask') {
        // Start drawing immediately
        draw(e);
      } else if (mode === 'sam') {
        // SAM interactive mode - send point to backend
        addSAMPoint(Math.round(x), Math.round(y));
      } else {
        // For YOLO mode, record point
        clickPoints.push({x: Math.round(x), y: Math.round(y)});
        
        // Draw a marker to indicate click
        const markerColor = '#10b981'; // Green for YOLO
        
        // Outer circle
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI * 2);
        ctx.strokeStyle = markerColor;
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Inner circle
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fillStyle = markerColor;
        ctx.fill();
        
        // Show point number
        ctx.font = 'bold 14px Inter';
        ctx.fillStyle = 'white';
        ctx.strokeStyle = markerColor;
        ctx.lineWidth = 3;
        ctx.strokeText(clickPoints.length.toString(), x + 12, y - 8);
        ctx.fillText(clickPoints.length.toString(), x + 12, y - 8);
        
        showStatus(`Point ${clickPoints.length} added. Click more points or process for YOLO segmentation.`, 'info');
      }
    }

    function draw(e) {
      if (!isDrawing || mode !== 'mask' || !currentImage) return;
      
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      
      // Draw on mask canvas
      maskCtx.lineWidth = brushSize;
      maskCtx.lineCap = 'round';
      maskCtx.lineJoin = 'round';
      maskCtx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
      maskCtx.beginPath();
      maskCtx.moveTo(lastX, lastY);
      maskCtx.lineTo(x, y);
      maskCtx.stroke();
      
      // Draw on visible canvas
      ctx.lineWidth = brushSize;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(x, y);
      ctx.stroke();
      
      // Update last position
      lastX = x;
      lastY = y;
    }

    function stopDrawing() {
      isDrawing = false;
    }

    // Clear mask
    clearBtn.addEventListener('click', () => {
      if (!currentImage) return;
      
      if (mode === 'sam') {
        // Clear SAM clicks
        clearSAMClicks();
      } else {
        // Redraw original image
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(currentImage, 0, 0);
        
        // Clear mask canvas and points
        maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
        clickPoints = [];
        
        showStatus('Mask cleared. Start over!', 'info');
        setTimeout(hideStatus, 2000);
      }
    });

    // Process image
    processBtn.addEventListener('click', async () => {
      if (!currentImage) {
        showStatus('Please upload an image first.', 'error');
        return;
      }

      showStatus('Processing image...', 'info');
      
      // Prepare form data
      const formData = new FormData();
      
      // Add image
      const imageBlob = await fetch(currentImage.src).then(res => res.blob());
      formData.append('image', imageBlob, 'image.png');
      
      // Add mask or points
      if (mode === 'mask') {
        // Convert mask canvas to blob
        maskCanvas.toBlob((blob) => {
          formData.append('mask', blob, 'mask.png');
          formData.append('mode', 'brush');
          
          // Save to backend
          saveToBackend(formData);
        });
      } else {
        // Add click points as JSON for SAM or YOLO
        const pointsBlob = new Blob([JSON.stringify(clickPoints)], { type: 'application/json' });
        formData.append('points', pointsBlob, 'points.json');
        formData.append('mode', mode); // 'sam' or 'yolo'
        
        // Save to backend
        saveToBackend(formData);
      }
    });

    async function saveToBackend(formData) {
      try {
        // Show loading animation
        processingLoader.classList.add('show');
        showStatus('Processing image...', 'info');
        
        // Send to backend upload endpoint
        const response = await fetch('/upload', {
          method: 'POST',
          body: formData
        });
        
        // Hide loading animation
        processingLoader.classList.remove('show');
        
        if (!response.ok) {
          throw new Error(`Upload failed: ${response.statusText}`);
        }
        
        const result = await response.json();
        console.log('Upload successful:', result);
        
        // Store result for inpainting
        lastUploadResult = result;
        
        // Show success message based on mode
        if (result.mode === 'sam' && result.segmentation === 'sam_generated') {
          showStatus('‚úì SAM segmentation completed! Mask generated and saved.', 'success');
          
          // Display the generated mask
          if (result.mask_path) {
            displayMask(result.mask_path, '‚úì SAM mask generated and displayed!');
          }
          
          // Show remove button
          removeBtn.style.display = 'inline-block';
        } else if (result.mode === 'yolo' && result.segmentation === 'yolo_generated') {
          // Show YOLO detection info
          let statusMsg = '‚úì YOLO detection completed! ';
          if (result.detection) {
            const det = result.detection;
            if (det.detected) {
              statusMsg += `Detected: ${det.class_name} (${(det.confidence * 100).toFixed(1)}%)`;
              // Show remove button with detected object name
              removeBtn.style.display = 'inline-block';
              removeBtn.textContent = `‚ú® Remove ${det.class_name}`;
            } else {
              statusMsg += 'No object detected at click point.';
            }
          } else if (result.detections) {
            const detected = result.detections.filter(d => d.detected).length;
            statusMsg += `${detected}/${result.detections.length} objects detected.`;
            if (detected > 0) {
              removeBtn.style.display = 'inline-block';
              removeBtn.textContent = `‚ú® Remove Objects`;
            }
          }
          showStatus(statusMsg, 'success');
          
          // Display the generated mask
          if (result.mask_path) {
            displayMask(result.mask_path, statusMsg);
          }
        } else if (result.mode === 'brush') {
          showStatus('‚úì Brush mask saved successfully!', 'success');
          removeBtn.style.display = 'inline-block';
          removeBtn.textContent = '‚ú® Remove Object';
        } else if (result.segmentation_error) {
          showStatus(`‚ö† Saved but segmentation failed: ${result.segmentation_error}`, 'error');
        } else {
          showStatus('‚úì Images saved successfully!', 'success');
        }
        
        // Helper function to display mask overlay
        function displayMask(maskPath, successMsg) {
          const maskUrl = '/' + maskPath.replace('app/static/', '');
          const maskImg = new Image();
          maskImg.onload = () => {
            // Draw semi-transparent mask overlay
            ctx.globalAlpha = 0.5;
            ctx.drawImage(maskImg, 0, 0);
            ctx.globalAlpha = 1.0;
            showStatus(successMsg, 'success');
          };
          maskImg.src = maskUrl + '?t=' + Date.now(); // Cache bust
        }
        
        // If backend returns a processed image URL, display it
        if (result.processed_image_url) {
          resultImage.src = result.processed_image_url;
          resultContainer.classList.add('show');
        }
      } catch (error) {
        processingLoader.classList.remove('show');
        console.error('Error:', error);
        showStatus(`Error: ${error.message}`, 'error');
      }
    }
    
    // Remove object button
    removeBtn.addEventListener('click', async () => {
      // Check if we're in SAM mode or regular mode
      if (mode === 'sam') {
        // SAM mode - use SAM process endpoint
        processSAMAndRemove();
        return;
      }
      
      if (!lastUploadResult) {
        showStatus('Please process an image first.', 'error');
        return;
      }
      
      try {
        // Show inpainting loader
        inpaintingLoader.classList.add('show');
        showStatus('üé® Removing object with LaMa...', 'info');
        removeBtn.disabled = true;
        
        // Determine object name
        let objectName = 'object';
        if (lastUploadResult.detection && lastUploadResult.detection.detected) {
          objectName = lastUploadResult.detection.class_name;
        } else if (lastUploadResult.detections) {
          const detectedObjects = lastUploadResult.detections
            .filter(d => d.detected)
            .map(d => d.class_name);
          if (detectedObjects.length > 0) {
            objectName = detectedObjects.join(', ');
          }
        }
        
        // Call remove endpoint
        const response = await fetch('/remove', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            image_path: lastUploadResult.image_path,
            mask_path: lastUploadResult.mask_path,
            object_name: objectName
          })
        });
        
        // Hide inpainting loader
        inpaintingLoader.classList.remove('show');
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.detail || 'Removal failed');
        }
        
        const result = await response.json();
        console.log('Removal successful:', result);
        console.log('Full result object:', JSON.stringify(result, null, 2));
        
        // Display the result
        if (result.output_url) {
          const imageUrl = result.output_url + '?t=' + Date.now();
          console.log('Setting image URL to:', imageUrl);
          
          // Hide placeholder, show image
          resultPlaceholder.style.display = 'none';
          resultImage.style.display = 'block';
          resultImage.src = imageUrl;
          resultImage.classList.add('result-ready');
          
          // Add load event listener to verify image loads
          resultImage.onload = () => {
            console.log('‚úÖ Result image loaded successfully!');
          };
          resultImage.onerror = (e) => {
            console.error('‚ùå Failed to load result image:', e);
            console.error('Image src:', resultImage.src);
            showStatus('Error: Failed to load result image', 'error');
          };
          
          showStatus(`‚úÖ ${objectName} removed successfully! Time: ${result.inference_time?.toFixed(1)}s`, 'success');
        } else {
          console.error('No output_url in result');
        }
        
        removeBtn.disabled = false;
        
      } catch (error) {
        inpaintingLoader.classList.remove('show');
        console.error('Error:', error);
        showStatus(`‚ùå Error: ${error.message}`, 'error');
        removeBtn.disabled = false;
      }
    });
    
    // SAM Interactive Functions
    async function uploadToSAM() {
      if (!currentImage) return;
      
      try {
        showStatus('Uploading to SAM...', 'info');
        
        const response = await fetch('/sam/upload', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            image: currentImage.src,
            session_id: samSessionId
          })
        });
        
        if (!response.ok) throw new Error('SAM upload failed');
        
        const result = await response.json();
        console.log('SAM upload successful:', result);
        showStatus('SAM ready! Click on objects to segment.', 'success');
        setTimeout(hideStatus, 2000);
      } catch (error) {
        console.error('SAM upload error:', error);
        showStatus('Error uploading to SAM: ' + error.message, 'error');
      }
    }
    
    async function addSAMPoint(x, y, isPositive = true) {
      try {
        const response = await fetch('/sam/add_point', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            session_id: samSessionId,
            x: x,
            y: y,
            is_positive: isPositive
          })
        });
        
        if (!response.ok) throw new Error('SAM point add failed');
        
        const result = await response.json();
        
        // Display the painted image with mask
        if (result.painted_image) {
          const img = new Image();
          img.onload = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0);
          };
          img.src = result.painted_image;
        }
        
        showStatus('Point added! Click more or Add Mask to save.', 'success');
      } catch (error) {
        console.error('SAM point error:', error);
        showStatus('Error adding point: ' + error.message, 'error');
      }
    }
    
    async function clearSAMClicks() {
      try {
        const response = await fetch('/sam/clear_clicks', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ session_id: samSessionId })
        });
        
        if (!response.ok) throw new Error('SAM clear failed');
        
        const result = await response.json();
        
        // Display original image
        if (result.image) {
          const img = new Image();
          img.onload = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0);
          };
          img.src = result.image;
        }
        
        showStatus('Clicks cleared!', 'info');
        setTimeout(hideStatus, 2000);
      } catch (error) {
        console.error('SAM clear error:', error);
        showStatus('Error clearing: ' + error.message, 'error');
      }
    }
    
    // Add Mask button
    addMaskBtn.addEventListener('click', async () => {
      try {
        const response = await fetch('/sam/add_mask', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ session_id: samSessionId })
        });
        
        if (!response.ok) throw new Error('SAM add mask failed');
        
        const result = await response.json();
        samMasks = result.mask_names || [];
        
        // Display image with all masks
        if (result.image) {
          const img = new Image();
          img.onload = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0);
          };
          img.src = result.image;
        }
        
        showStatus(`Mask added! Total masks: ${samMasks.length}`, 'success');
      } catch (error) {
        console.error('SAM add mask error:', error);
        showStatus('Error adding mask: ' + error.message, 'error');
      }
    });
    
    // Delete Masks button
    deleteMasksBtn.addEventListener('click', async () => {
      try {
        const response = await fetch('/sam/delete_masks', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ session_id: samSessionId })
        });
        
        if (!response.ok) throw new Error('SAM delete masks failed');
        
        const result = await response.json();
        samMasks = [];
        
        // Display original image
        if (result.image) {
          const img = new Image();
          img.onload = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0);
          };
          img.src = result.image;
        }
        
        showStatus('All masks deleted!', 'info');
        setTimeout(hideStatus, 2000);
      } catch (error) {
        console.error('SAM delete masks error:', error);
        showStatus('Error deleting masks: ' + error.message, 'error');
      }
    });
    
    // Process SAM masks and remove objects
    async function processSAMAndRemove() {
      try {
        if (samMasks.length === 0) {
          showStatus('Please add at least one mask first.', 'error');
          return;
        }
        
        // Show inpainting loader
        inpaintingLoader.classList.add('show');
        showStatus('üé® Processing SAM masks with LaMa...', 'info');
        removeBtn.disabled = true;
        
        const response = await fetch('/sam/process', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            session_id: samSessionId,
            num_inference_steps: 20,
            guidance_scale: 2.5,
            seed: 300000
          })
        });
        
        // Hide inpainting loader
        inpaintingLoader.classList.remove('show');
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.detail || 'Processing failed');
        }
        
        const result = await response.json();
        console.log('SAM processing successful:', result);
        
        // Display the result
        if (result.output_url) {
          const imageUrl = result.output_url + '?t=' + Date.now();
          
          // Hide placeholder, show image
          resultPlaceholder.style.display = 'none';
          resultImage.style.display = 'block';
          resultImage.src = imageUrl;
          resultImage.classList.add('result-ready');
          
          resultImage.onload = () => {
            console.log('‚úÖ Result image loaded successfully!');
          };
          resultImage.onerror = (e) => {
            console.error('‚ùå Failed to load result image:', e);
            showStatus('Error: Failed to load result image', 'error');
          };
          
          const maskText = result.num_masks > 1 ? `${result.num_masks} masks` : '1 mask';
          showStatus(`‚úÖ Objects removed successfully! (${maskText}) Time: ${result.inference_time?.toFixed(1)}s`, 'success');
        } else {
          console.error('No output_url in result');
        }
        
        removeBtn.disabled = false;
        
      } catch (error) {
        inpaintingLoader.classList.remove('show');
        console.error('Error:', error);
        showStatus(`‚ùå Error: ${error.message}`, 'error');
        removeBtn.disabled = false;
      }
    }
    
    // Initialize canvas as hidden
    canvas.style.display = 'none';
  </script>
</body>
</html>
